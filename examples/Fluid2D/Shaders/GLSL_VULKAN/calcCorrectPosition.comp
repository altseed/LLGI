#version 430
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle
{
    vec2 Current;
    vec2 Next;
    vec2 Velocity;
    float Pscl;
    uint IsFix;
};

layout(set = 0, binding = 0, std140) uniform CB
{
    ivec2 GridNum;
    ivec2 GridSize;
    float EffectiveRadius;
    float Density;
    float Eps;
    float Dt;
    float Wpoly6;
    float GWspiky;
} _60;

layout(set = 2, binding = 2, std430) buffer gridIndicesTable
{
    ivec2 _data[];
} gridIndicesTable_1;

layout(set = 2, binding = 0, std430) buffer particles
{
    Particle _data[];
} particles_1;

layout(set = 2, binding = 1, std430) buffer gridTable
{
    ivec2 _data[];
} gridTable_1;

ivec2 GetGridPos(vec2 pos, vec2 gridSize)
{
    return ivec2(pos / gridSize);
}

int GetHash(ivec2 gridPos, int num)
{
    return gridPos.x + (gridPos.y * num);
}

vec2 CalcPositionCorrectionCell(ivec2 gridPos, int i, vec2 pos0)
{
    ivec2 param = gridPos;
    int param_1 = _60.GridNum.x;
    int gridHash = GetHash(param, param_1);
    int startIndex = gridIndicesTable_1._data[gridHash].x;
    float h = _60.EffectiveRadius;
    float r0 = _60.Density;
    vec2 dp = vec2(0.0);
    float dt = _60.Dt;
    float si = particles_1._data[i].Pscl;
    if (startIndex != 2147483647)
    {
        uint endIndex = uint(gridIndicesTable_1._data[gridHash].y);
        uint _117 = uint(startIndex);
        for (uint j = _117; j < endIndex; j++)
        {
            if (gridTable_1._data[j].y == i)
            {
                continue;
            }
            vec2 pos1 = particles_1._data[gridTable_1._data[j].y].Next;
            vec2 rij = pos0 - pos1;
            float r = length(rij);
            if ((r <= h) && (r > 0.0))
            {
                float scorr = 0.0;
                float q = (h * h) - (r * r);
                float q2 = (h * h) - ((0.039999999105930328369140625 * h) * h);
                float ww = (((_60.Wpoly6 * q) * q) * q) / (((_60.Wpoly6 * q2) * q2) * q2);
                scorr = (((-0.100000001490116119384765625) * pow(ww, 4.0)) * dt) * dt;
                float q_1 = h - r;
                float sj = particles_1._data[gridTable_1._data[j].y].Pscl;
                dp += ((((rij * ((_60.GWspiky * q_1) * q_1)) / vec2(r)) * ((si + sj) + scorr)) / vec2(r0));
            }
        }
    }
    return dp;
}

vec2 CalcPositionCorrection(int id)
{
    vec2 pos = particles_1._data[id].Next;
    float h = _60.EffectiveRadius;
    vec2 param = pos - vec2(h);
    vec2 param_1 = vec2(_60.GridSize);
    ivec2 grid_pos0 = GetGridPos(param, param_1);
    vec2 param_2 = pos + vec2(h);
    vec2 param_3 = vec2(_60.GridSize);
    ivec2 grid_pos1 = GetGridPos(param_2, param_3);
    vec2 dpij = vec2(0.0);
    for (int y = grid_pos0.y; y <= grid_pos1.y; y++)
    {
        for (int x = grid_pos0.x; x <= grid_pos1.x; x++)
        {
            ivec2 n_grid_pos = ivec2(x, y);
            ivec2 param_4 = n_grid_pos;
            int param_5 = id;
            vec2 param_6 = pos;
            dpij += CalcPositionCorrectionCell(param_4, param_5, param_6);
        }
    }
    return dpij;
}

void _main(uvec3 dtid)
{
    int id = int(dtid.x);
    if (particles_1._data[id].IsFix != 0u)
    {
        return;
    }
    int param = id;
    particles_1._data[id].Next += CalcPositionCorrection(param);
}

void main()
{
    uvec3 dtid = gl_GlobalInvocationID;
    uvec3 param = dtid;
    _main(param);
}

